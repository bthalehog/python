#!/usr/bin/env python3
"""
An autogenerated testfile for python.
"""

import unittest
from importlib import util
from io import StringIO
import os
import sys
from unittest.mock import patch
from unittest import TextTestRunner
from examiner import ExamTestCaseExam, ExamTestResult, tags
from examiner import import_module, find_path_to_assignment


FILE_DIR = os.path.dirname(os.path.realpath(__file__))
REPO_PATH = find_path_to_assignment(FILE_DIR)

if REPO_PATH not in sys.path:
    sys.path.insert(0, REPO_PATH)

# Path to file and basename of the file to import
exam = import_module(REPO_PATH, "exam")



class Test1Assignment1(ExamTestCaseExam):
    """
    Each assignment has 1 testcase with multiple asserts.

    The different asserts https://docs.python.org/3.6/library/unittest.html#test-cases
    """
    points_for_pass = 20
    points_worth = 20
    @tags("1")
    def test_a_create_acronyms_teachers(self):
        """
        Testar att "create_acronyms" returnerar rätt för lärare. Inkluderar icke unika namn.
        Använder följande som input
        {arguments}
        Förväntar sig att följande returneras:
        {correct}
        Fick istället:
        {student}
        """
        self._multi_arguments = [
            "Andreas arnesson", "teacher",
            "Emil Folino", "teacher",
            "andromeda Aro", "teacher",
            "Anders Aronsson", "teacher",
            "q"
        ]
        with patch('builtins.input', side_effect=self._multi_arguments):
            akronyms = exam.create_acronyms()
            self.assertEqual(
                akronyms, 
                ['aan', 'aao', 'aar', 'efo']
            )



    @tags("1")
    def test_b_create_acronyms_students(self):
        """
        Testar att "create_acronyms" returnerar rätt för studenter. Inkluderar icke unika namn.
        Använder följande som input
        {arguments}
        Förväntar sig att följande returneras:
        {correct}
        Fick istället:
        {student}
        """
        self._multi_arguments = [
            "Andreas arnesson", "2012",
            "emil Folino", "2018",
            "andromeda Aro", "2012",
            "Anders Aronsson", "2012",
            "Andreas arnesson", "2018",
            "q"
        ]

        with patch('builtins.input', side_effect=self._multi_arguments):
            akronyms = exam.create_acronyms()
            self.assertEqual(
                akronyms, 
                ['anan12', 'anao12', 'anar12', 'anar18', 'emfo18']
            )



class Test2Assignment2(ExamTestCaseExam):
    """
    Each assignment has 2 testcase with multiple asserts.

    The different asserts https://docs.python.org/3.6/library/unittest.html#test-cases
    """
    points_worth = 10
    @tags("2")
    def test_a_convert(self):
        """
        Testar hextal utan 0.
        Använder följande som input
        {arguments}
        Förväntar att följande returneras:
        {correct}
        Fick följande:
        {student} 
        """
        self._argument = (255, 255, 255)
        self.assertEqual(exam.convert_to_hex((255, 255, 255)), "#ffffff")
        self._argument = (230, 230, 250)
        self.assertEqual(exam.convert_to_hex((230, 230, 250)), "#e6e6fa")
        self._argument = (233, 150, 122)
        self.assertEqual(exam.convert_to_hex((233, 150, 122)), "#e9967a")
        self._argument = (34, 139, 34)
        self.assertEqual(exam.convert_to_hex((34, 139, 34)), "#228b22")

    @tags("2")
    def test_b_zeropad_hex(self):
        """
        Testar att hex tal under 10 börjar med 0.
        Använder följande som input
        {arguments}
        Förväntar att följande returneras:
        {correct}
        Fick följande:
        {student} 
        """
        self._argument = (255, 48, 3)
        self.assertEqual(exam.convert_to_hex((255, 48, 3)), "#ff3003")
        self._argument = (70, 163, 10)
        self.assertEqual(exam.convert_to_hex((70, 163, 10)), "#46a30a")
        self._argument = (10, 26, 0)
        self.assertEqual(exam.convert_to_hex((10, 26, 0)), "#0a1a00")
        self._argument = (1, 2, 1)
        self.assertEqual(exam.convert_to_hex((1, 2, 1)), "#010201")



class Test3Assignment3(ExamTestCaseExam):
    """
    Each assignment has 1 testcase with multiple asserts.

    The different asserts https://docs.python.org/3.6/library/unittest.html#test-cases
    """
    points_worth = 10
    @tags("3")
    def test_a_yatzee_upper_one_multiple(self):
        """
        Testar att "yahtzee_upper" returnerar rätt där bara en siffrar finns med flera gånger.
        Använder följande som argument
        {arguments}
        Förväntar sig att följande returneras:
        {correct}
        Fick istället:
        {student}
        """
        self._argument = [2, 3, 5, 5, 6]
        self.assertEqual(exam.yahtzee_upper([2, 3, 5, 5, 6]), (5, 10))
        self._argument = [1, 1, 1, 1, 3]
        self.assertEqual(exam.yahtzee_upper([1, 1, 1, 1, 3]), (1, 4))


    @tags("3")
    def test_b_yatzee_upper_two_multiple(self):
        """
        Testar att "yahtzee_upper" returnerar rätt där två siffror finns med flera gånger.
        Använder följande som argument
        {arguments}
        Förväntar sig att följande returneras:
        {correct}
        Fick istället:
        {student}
        """
        self._argument = [1, 1, 1, 3, 3]
        self.assertEqual(exam.yahtzee_upper([1, 1, 1, 3, 3]), (3, 6))



    @tags("3")
    def test_c_yatzee_upper_no_multiple(self):
        """
        Testar att "yahtzee_upper" returnerar rätt där ingen siffra finns med flera gånger.
        Använder följande som argument
        {arguments}
        Förväntar sig att följande returneras:
        {correct}
        Fick istället:
        {student}
        """
        self._argument = [1, 2, 3, 4, 5]
        self.assertEqual(exam.yahtzee_upper([1, 2, 3, 4, 5]), (5, 5))



    @tags("3")
    def test_d_yatzee_upper_only_one_number(self):
        """
        Testar att "yahtzee_upper" returnerar rätt där bara en siffra är med flera gånger.
        Använder följande som argument
        {arguments}
        Förväntar sig att följande returneras:
        {correct}
        Fick istället:
        {student}
        """
        self._argument = [6, 6, 6, 6, 6]
        self.assertEqual(exam.yahtzee_upper([6, 6, 6, 6, 6]), (6, 30))



class Test4Assignment4(ExamTestCaseExam):
    """
    Each assignment has 1 testcase with multiple asserts.

    The different asserts https://docs.python.org/3.6/library/unittest.html#test-cases
    """
    points_worth = 10

    @classmethod
    def setUpClass(cls):
        """
        To find all relative files that are read or written to.
        """
        os.chdir(REPO_PATH)

    @tags("4")
    def test_a_module_exist(self):
        """
        Testar att rätt modul är skapad.
        |G|Förväntar att följande modul finns men hittades inte:|/RE|
        {arguments}
        """
        self._argument = "reader"
        self.assertIsNotNone(util.find_spec("reader"))

    @tags("4")
    def test_b_find_names(self):
        """
        Testar att rätt värden returneras.
        Förväntar att följande returneras:
        {correct}
        Fick följande:
        {student}
        """
        self.assertEqual(exam.find_names(), {
            'Stephen': 184, 'Christine': 2, 'Haines': 90,
            'Connolly': 2, 'Chrysostomos': 2, 'Buck': 142,
            'Malachi': 10
        })


    @tags("4")
    def test_c_read_file(self):
        """
        Testar läsa upp namnen från names.txt med read_file().
        Använder följande som argument:
        {arguments}
        Förväntar att följande returneras:
        {correct}
        Fick följande:
        {student} 
        """
        reader = import_module(REPO_PATH, "reader")
        self._argument = "names.txt"

        names = reader.read_file("names.txt")
        self.assertEqual(names, "Buck\nStephen\nChristine\nChrysostomos\nMalachi\nHaines\nConnolly")




class Test5Assignment5(ExamTestCaseExam):
    """
    Each assignment has 1 testcase with multiple asserts.

    The different asserts https://docs.python.org/3.6/library/unittest.html#test-cases
    """
    points_worth = 10
    @tags("5")
    def test_a_has_one_leapday(self):
        """
        Testar med årtal där det finns 1 skottdag.
        Använder följande som input
        {arguments}
        Förväntar att följande returneras:
        {correct}
        Fick följande:
        {student} 
        """
        self._multi_arguments = [2016, 2017]
        self.assertEqual(exam.leap_days(2016, 2017), 1)
        self._multi_arguments = [2000, 2001]
        self.assertEqual(exam.leap_days(2000, 2001), 1)

    @tags("5")
    def test_b_has_zero_leapday(self):
        """
        Testar med årtal där det finns 0 skottdagar.
        Använder följande som input
        {arguments}
        Förväntar att följande returneras:
        {correct}
        Fick följande:
        {student} 
        """
        self._multi_arguments = [2019, 2020]
        self.assertEqual(exam.leap_days(2019, 2020), 0)
        self._multi_arguments = [1900, 1901]
        self.assertEqual(exam.leap_days(1900, 1901), 0)
        self._multi_arguments = [2800, 2801]
        self.assertEqual(exam.leap_days(2800, 2801), 0)
        self._multi_arguments = [123456, 123456]
        self.assertEqual(exam.leap_days(123456, 123456), 0)

    @tags("5")
    def test_c_has_many_leapday(self):
        """
        Testar med årtal där det finns flera skottdagar.
        Använder följande som input
        {arguments}
        Förväntar att följande returneras:
        {correct}
        Fick följande:
        {student} 
        """
        self._multi_arguments = [2000, 2005]
        self.assertEqual(exam.leap_days(2000, 2005), 2)
        self._multi_arguments = [1234, 5678]
        self.assertEqual(exam.leap_days(1234, 5678), 1077)
        self._multi_arguments = [123456, 7891011]
        self.assertEqual(exam.leap_days(123456, 7891011), 1881475)


if __name__ == '__main__':
    runner = TextTestRunner(resultclass=ExamTestResult, verbosity=2)
    unittest.main(testRunner=runner, exit=False)
